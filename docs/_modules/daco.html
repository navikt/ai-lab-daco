

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>daco &mdash; DACO 0.0.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> DACO
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Using DACO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../daco_full_doc.html">DACO documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">DACO</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>daco</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for daco</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: daco</span>
<span class="sd">   :platform: Unix, macOS</span>
<span class="sd">   :synopsis: Tool for comparing two datasets.</span>

<span class="sd">.. moduleauthor:: Jon Vegard Sparre</span>
<span class="sd">                  Robindra Prabhu</span>

<span class="sd">.. todo::</span>
<span class="sd">    - sequential vs tabular data (long term)</span>
<span class="sd">    - local and global metrics</span>
<span class="sd">    - differential privacy (long term)</span>
<span class="sd">    - privacy checks</span>
<span class="sd">    - mean, variance, ... ( this is available in pandas)</span>
<span class="sd">    - plotting/smart plotting, i.e. show only anomalies</span>
<span class="sd">    - pull plots based on the output from pd.dataframe.describe</span>
<span class="sd">    - allow setting range, density, binning, etc. for each variable manually?</span>
<span class="sd">    - set a random seed globally in class</span>
<span class="sd">    - log-axes in plots</span>
<span class="sd">    - IdentityDisclosure</span>
<span class="sd">    - AttributeDisclosure</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">scipy</span><span class="o">,</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">stats</span>
<span class="kn">from</span> <span class="nn">daco_plot</span> <span class="k">import</span> <span class="n">plot</span>

<div class="viewcode-block" id="daco"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco">[docs]</a><span class="k">class</span> <span class="nc">daco</span><span class="p">(</span><span class="n">plot</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot; Class for comparing two Pandas dataframes.</span>

<span class="sd">  The purpose of this class is to easily compare datasets in different</span>
<span class="sd">  settings, e.g. check if a synthetic version of a dataset is good enoug</span>
<span class="sd">  for your use.</span>
<span class="sd">  &quot;&quot;&quot;</span>
<div class="viewcode-block" id="daco.__init__"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.__init__">[docs]</a>  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df1</span><span class="p">,</span> <span class="n">df2</span><span class="p">,</span> <span class="n">name1</span><span class="o">=</span><span class="s1">&#39;df1&#39;</span><span class="p">,</span> <span class="n">name2</span><span class="o">=</span><span class="s1">&#39;df2&#39;</span><span class="p">,</span> <span class="n">file_dir</span><span class="o">=</span><span class="s2">&quot;plots/&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param df1: dataframe to be compared. Must have header and dtype for all columns.</span>
<span class="sd">    :param df2: dataframe to be compared. Must have header and dtype for all columns. This is\</span>
<span class="sd">    treated as the synthetic version of df1 throughout the module.</span>
<span class="sd">    :type df1: dataframe</span>
<span class="sd">    :type df2: dataframe</span>

<span class="sd">    :param file_dir: path to directory where plots are saved</span>
<span class="sd">    :type file_dir: str</span>
<span class="sd">    :param name1: names of dataframes, used as keys in dictionaries containing info about dataframes</span>
<span class="sd">    :param name2: names of dataframes, used as keys in dictionaries containing info about dataframes</span>
<span class="sd">    :type name1: str</span>
<span class="sd">    :type name2: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Doing some checks of the dataframes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_checkDataframes</span><span class="p">(</span><span class="n">df1</span><span class="p">,</span> <span class="n">df2</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">df1</span>      <span class="o">=</span> <span class="n">df1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">df2</span>      <span class="o">=</span> <span class="n">df2</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">file_dir</span> <span class="o">=</span> <span class="n">file_dir</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name1</span> <span class="o">=</span> <span class="n">name1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name2</span> <span class="o">=</span> <span class="n">name2</span>


    <span class="c1"># Creating dicts for saving values for different metrics</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">p_D_chisquare</span>       <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bhattacharyya_dis</span>   <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">hellinger_div</span>       <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kullbackleibler_div</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ks2_test_val</span>        <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">wasserstein_val</span>     <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Setting plotting colors and some parameters</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tab:green&#39;</span><span class="p">,</span> <span class="s1">&#39;tab:blue&#39;</span><span class="p">]</span>
    <span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;xtick.labelsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;ytick.labelsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;legend.fontsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span>

    <span class="c1"># Creating dir for saving plots etc.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file_dir</span><span class="p">):</span>
      <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">file_dir</span><span class="p">)</span></div>

<div class="viewcode-block" id="daco._checkDataframes"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco._checkDataframes">[docs]</a>  <span class="k">def</span> <span class="nf">_checkDataframes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df1</span><span class="p">,</span> <span class="n">df2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checking whether the dataframes provided fullfills the requirements:</span>

<span class="sd">    - The input should be pandas dataframes</span>
<span class="sd">    - Only float or categorical variables</span>
<span class="sd">    - Same column names in both frames</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO implement method for checking that categorical columns in frame 1 and 2</span>
    <span class="c1"># contains all values</span>

    <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="p">[</span><span class="n">df1</span><span class="p">,</span> <span class="n">df2</span><span class="p">]:</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">())):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;One of the daco-inputs is not a Pandas dataframe&quot;</span><span class="p">)</span>

      <span class="n">col_names</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="s1">&#39;category&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">col_names</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Your dataframes has other datatypes than numerical and categorical&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">df1</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">df2</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Your dataframes does not contain the same columns&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="daco.numericalComparing"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.numericalComparing">[docs]</a>  <span class="k">def</span> <span class="nf">numericalComparing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compare the mean, variance, etc. of the numerical variable between the</span>
<span class="sd">    two dataframes. For each numerical variable we calculate the mean of the</span>
<span class="sd">    values in both dataframes, then we divide the mean value of the variable in</span>
<span class="sd">    the first dataframe on the second one to find how much they differ.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">      desc_compare : dict</span>
<span class="sd">        contains the relative mean values of all numerical variables in both</span>
<span class="sd">        dataframes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df1</span>
    <span class="n">df2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df2</span>

    <span class="n">desc1</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
    <span class="n">desc2</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>

    <span class="n">desc_compare</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">df1</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;number&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
      <span class="n">value1</span> <span class="o">=</span> <span class="n">desc1</span><span class="o">.</span><span class="n">mean</span><span class="p">()[</span><span class="n">variable</span><span class="p">]</span>
      <span class="n">value2</span> <span class="o">=</span> <span class="n">desc2</span><span class="o">.</span><span class="n">mean</span><span class="p">()[</span><span class="n">variable</span><span class="p">]</span>
      <span class="n">desc_compare</span><span class="p">[</span><span class="s1">&#39;mean_rel_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">variable</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value1</span><span class="o">/</span><span class="n">value2</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">desc_compare</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">desc_compare</span><span class="p">)</span></div>

<div class="viewcode-block" id="daco.findDistributions"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.findDistributions">[docs]</a>  <span class="k">def</span> <span class="nf">findDistributions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bins_</span><span class="o">=</span><span class="s1">&#39;sturges&#39;</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find distributions of all variables/columns in dataframes loaded</span>
<span class="sd">    into daco and save them in dictionaries.</span>

<span class="sd">    :param bins: number of bins in histogram/distribution or how to find the number of bins.</span>
<span class="sd">    :type bins: int</span>

<span class="sd">    :param density: if True a normalised distribution is returned.</span>
<span class="sd">    :type density: bool</span>

<span class="sd">    :returns: distributions</span>
<span class="sd">    :rtype: dict</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    By giving two Pandas dataframes we find the distributions:</span>

<span class="sd">    &gt;&gt;&gt; daco_obj = daco(df1,df2)</span>
<span class="sd">    &gt;&gt;&gt; dist = daco_obj.findDistributions()</span>
<span class="sd">    &gt;&gt;&gt; print(dist)</span>
<span class="sd">    {&#39;df1&#39;: {&#39;age&#39;: (array([0.01964384, 0.0258, ...]}, &#39;df2&#39;: {...}}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df1</span>
    <span class="n">df2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df2</span>
    <span class="n">name1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name1</span>
    <span class="n">name2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name2</span>

    <span class="n">hist1</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">hist2</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">df1_err</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">df2_err</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># looping over all columns containing numerical variables</span>
    <span class="n">column_numerical</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span>
    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">column_numerical</span><span class="p">:</span>
      <span class="n">min_val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">df1</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">df2</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
      <span class="n">max_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">df1</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">df2</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
      <span class="n">range_</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">)</span>

      <span class="n">hist1</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">df1</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
                                        <span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins_</span>
                                        <span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">range_</span>
                                        <span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">)</span>
      <span class="n">hist2</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">df2</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
                                        <span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">hist1</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">)][</span><span class="mi">1</span><span class="p">]</span>
                                        <span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">range_</span>
                                        <span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">)</span>
      <span class="c1"># Calculating the error of each bin: err = 1 / sqrt( N ) * sqrt(  n_i / N ),</span>
      <span class="c1"># i.e. the weight is w = 1 / N, where N is the total number of samples in the histogram</span>
      <span class="n">df1_err</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">df1</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
                                        <span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins_</span>
                                        <span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">range_</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hist1</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">)][</span><span class="mi">0</span><span class="p">])</span>
      <span class="n">df2_err</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">df2</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
                                        <span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">hist1</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">)][</span><span class="mi">1</span><span class="p">]</span>
                                        <span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">range_</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hist2</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">)][</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># looping over all columns containing categorical variables</span>
    <span class="n">column_categories</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;category&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span>
    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">column_categories</span><span class="p">:</span>
      <span class="n">value_count1</span> <span class="o">=</span> <span class="n">df1</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
      <span class="n">value_count2</span> <span class="o">=</span> <span class="n">df2</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
      <span class="n">norm_1</span> <span class="o">=</span> <span class="n">value_count1</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
      <span class="n">norm_2</span> <span class="o">=</span> <span class="n">value_count2</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
      <span class="n">hist1</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value_count1</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="n">norm_1</span><span class="p">,</span> <span class="n">value_count1</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">categories</span><span class="p">]</span>
      <span class="n">hist2</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value_count2</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="n">norm_2</span><span class="p">,</span> <span class="n">value_count2</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">categories</span><span class="p">]</span>
      <span class="c1"># Calculating the error</span>
      <span class="n">df1_err</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">value_count1</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hist1</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">)][</span><span class="mi">0</span><span class="p">])</span>
      <span class="n">df2_err</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">value_count2</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hist2</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">)][</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">distributions</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">distributions</span><span class="p">[</span><span class="n">name1</span><span class="p">]</span> <span class="o">=</span> <span class="n">hist1</span>
    <span class="n">distributions</span><span class="p">[</span><span class="n">name2</span><span class="p">]</span> <span class="o">=</span> <span class="n">hist2</span>
    <span class="n">distributions</span><span class="p">[</span><span class="n">name1</span> <span class="o">+</span> <span class="s1">&#39;_err&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df1_err</span>
    <span class="n">distributions</span><span class="p">[</span><span class="n">name2</span> <span class="o">+</span> <span class="s1">&#39;_err&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df2_err</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">distributions</span> <span class="o">=</span> <span class="n">distributions</span>

    <span class="k">return</span> <span class="n">distributions</span></div>

<div class="viewcode-block" id="daco.chisquare"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.chisquare">[docs]</a>  <span class="k">def</span> <span class="nf">chisquare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Method for calculating the chisquare test using scipy.stats.chisquare.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">      var1 : str</span>
<span class="sd">        name of variable in the dataset to do the chisquare test.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">      D : float</span>
<span class="sd">        The chi-squared test statistic</span>
<span class="sd">      p : float</span>
<span class="sd">        p-value</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">distributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distributions</span>
    <span class="n">p_D_chisquare</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_D_chisquare</span>

    <span class="n">dist1</span> <span class="o">=</span> <span class="n">distributions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name1</span><span class="p">][</span><span class="n">var1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dist2</span> <span class="o">=</span> <span class="n">distributions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name2</span><span class="p">][</span><span class="n">var1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">D</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">chisquare</span><span class="p">(</span><span class="n">dist1</span><span class="p">,</span> <span class="n">dist2</span><span class="p">)</span>

    <span class="c1"># Saving results in dictionary</span>
    <span class="n">p_D_chisquare</span><span class="p">[</span><span class="n">var1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="n">D</span><span class="p">,</span> <span class="s1">&#39;pvalue&#39;</span><span class="p">:</span> <span class="n">p</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">D</span><span class="p">,</span> <span class="n">p</span></div>

<div class="viewcode-block" id="daco._hellingerDivergence"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco._hellingerDivergence">[docs]</a>  <span class="k">def</span> <span class="nf">_hellingerDivergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist1</span><span class="p">,</span> <span class="n">dist2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Private method calculating the Hellinger divergence.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">hellinger_div_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dist1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dist2</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">hellinger_div_value</span></div>

<div class="viewcode-block" id="daco.hellinger"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.hellinger">[docs]</a>  <span class="k">def</span> <span class="nf">hellinger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the Hellinger divergence for the distributions of</span>
<span class="sd">    var1 in the two dataframes.</span>
<span class="sd">    See `https://en.wikipedia.org/wiki/Hellinger_distance \</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Hellinger_distance&gt;`_</span>

<span class="sd">    :param var1: name of variable in the datasets to do calculate the Hellinger divergence for.</span>
<span class="sd">    :type var1: str</span>

<span class="sd">    :returns: hellinger_div. Ouput value is in range ``[0, sqrt(2)]``.</span>
<span class="sd">    :rtype: float</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">distributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distributions</span>
    <span class="n">hellinger_div</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hellinger_div</span>

    <span class="n">dist1</span> <span class="o">=</span> <span class="n">distributions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name1</span><span class="p">][</span><span class="n">var1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dist2</span> <span class="o">=</span> <span class="n">distributions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name2</span><span class="p">][</span><span class="n">var1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">hellinger_div_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hellingerDivergence</span><span class="p">(</span><span class="n">dist1</span><span class="p">,</span> <span class="n">dist2</span><span class="p">)</span>

    <span class="n">hellinger_div</span><span class="p">[</span><span class="n">var1</span><span class="p">]</span> <span class="o">=</span> <span class="n">hellinger_div_value</span>

    <span class="k">return</span> <span class="n">hellinger_div_value</span></div>

<div class="viewcode-block" id="daco.kullbackleibler"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.kullbackleibler">[docs]</a>  <span class="k">def</span> <span class="nf">kullbackleibler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate Kullback-Leibler divergence for the distributions of</span>
<span class="sd">    var1 in the two dataframes with scipy.stats.entropy.</span>

<span class="sd">    - `https://medium.com/@cotra.marko/making-sense-of-the-kullback-leibler-kl-divergence \</span>
<span class="sd">    &lt;https://medium.com/@cotra.marko/making-sense-of-the-kullback-leibler-kl-divergence&gt;`_</span>
<span class="sd">    - `https://en.wikipedia.org/wiki/Kullback–Leibler_divergence \</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Kullback–Leibler_divergence&gt;`_</span>

<span class="sd">    :param var1: name of variable to do calculate the Kullback-Leibler divergence for. Must be contained in the dataframes.</span>
<span class="sd">    :type var1: str</span>

<span class="sd">    :returns: kb_div</span>
<span class="sd">    :rtype: float</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">spec</span>

    <span class="n">distributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distributions</span>
    <span class="n">kullbackleibler_div</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kullbackleibler_div</span>

    <span class="n">dist1</span> <span class="o">=</span> <span class="n">distributions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name1</span><span class="p">][</span><span class="n">var1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dist2</span> <span class="o">=</span> <span class="n">distributions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name2</span><span class="p">][</span><span class="n">var1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># return np.sum( np.where( p != 0., p * np.log( p / np.where( q != 0., q, 1 ) ), 0 ) )</span>
    <span class="c1"># return sp.entropy(p, q)</span>

    <span class="c1"># kb_div = spec.kl_div(dist1, dist2)</span>
    <span class="n">kb_div</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="n">dist1</span><span class="p">,</span> <span class="n">dist2</span><span class="p">)</span>

    <span class="n">kullbackleibler_div</span><span class="p">[</span><span class="n">var1</span><span class="p">]</span> <span class="o">=</span> <span class="n">kb_div</span>

    <span class="k">return</span> <span class="n">kb_div</span></div>

<div class="viewcode-block" id="daco.wasserstein"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.wasserstein">[docs]</a>  <span class="k">def</span> <span class="nf">wasserstein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculating the Wasserstein/&quot;earth mover&#39;s distance&quot; with ``SciPy``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">      var1 : str</span>
<span class="sd">         name of variable to calculate for</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">wasserstein_distance</span>

    <span class="n">distributions</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distributions</span>
    <span class="n">wasserstein_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wasserstein_val</span>

    <span class="n">dist1</span> <span class="o">=</span> <span class="n">distributions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name1</span><span class="p">][</span><span class="n">var1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dist2</span> <span class="o">=</span> <span class="n">distributions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name2</span><span class="p">][</span><span class="n">var1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">wasserstein_val_</span> <span class="o">=</span> <span class="n">wasserstein_distance</span><span class="p">(</span><span class="n">dist1</span><span class="p">,</span> <span class="n">dist2</span><span class="p">)</span>

    <span class="n">wasserstein_val</span><span class="p">[</span><span class="n">var1</span><span class="p">]</span> <span class="o">=</span> <span class="n">wasserstein_val_</span>

    <span class="k">return</span> <span class="n">wasserstein_val_</span></div>

<div class="viewcode-block" id="daco.bhattacharyya"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.bhattacharyya">[docs]</a>  <span class="k">def</span> <span class="nf">bhattacharyya</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the Bhattacharyya distance for the distributions of</span>
<span class="sd">    var1 in the two dataframes.</span>
<span class="sd">    See `https://en.wikipedia.org/wiki/Bhattacharyya_distance \</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Bhattacharyya_distance&gt;`_</span>

<span class="sd">    :param var1: name of variable in the datasets to do calculate the Bhattacharyya distance for.</span>
<span class="sd">    :type var1: str</span>

<span class="sd">    :returns: b_dis</span>
<span class="sd">    :rtype: float</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">distributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distributions</span>
    <span class="n">bhattacharyya_dis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bhattacharyya_dis</span>

    <span class="n">dist1</span> <span class="o">=</span> <span class="n">distributions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name1</span><span class="p">][</span><span class="n">var1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dist2</span> <span class="o">=</span> <span class="n">distributions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name2</span><span class="p">][</span><span class="n">var1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">h</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="n">b_dis</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">dist1</span><span class="p">),</span> <span class="n">normalize</span><span class="p">(</span><span class="n">dist2</span><span class="p">))))</span>

    <span class="n">bhattacharyya_dis</span><span class="p">[</span><span class="n">var1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b_dis</span>

    <span class="k">return</span> <span class="n">b_dis</span></div>

<div class="viewcode-block" id="daco._findAndNormalizeDistances"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco._findAndNormalizeDistances">[docs]</a>  <span class="k">def</span> <span class="nf">_findAndNormalizeDistances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate and normalize distances for all numerical variables.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">      kl_array : array</span>
<span class="sd">        Kullback-Leibler values</span>
<span class="sd">      bha_array : array</span>
<span class="sd">        Bhattacharyya values</span>
<span class="sd">      hel_array : array</span>
<span class="sd">        Hellinger values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df1</span>

    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">df1</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;number&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">kullbackleibler</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">bhattacharyya</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">hellinger</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

    <span class="c1"># forcing KL to be a number between 1 and 0.</span>
    <span class="n">kl_array</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kullbackleibler_div</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
    <span class="n">bha_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bhattacharyya_dis</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="n">hel_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hellinger_div</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># maybe a stupid normalization</span>

    <span class="k">return</span> <span class="n">kl_array</span><span class="p">,</span> <span class="n">bha_array</span><span class="p">,</span> <span class="n">hel_array</span></div>

<div class="viewcode-block" id="daco.printDistances"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.printDistances">[docs]</a>  <span class="k">def</span> <span class="nf">printDistances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Print a nice markdown table with the distance metrics for all numerical</span>
<span class="sd">    variables.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">      distance_values : dict</span>
<span class="sd">        a dict containing all values calculated</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df1</span>

    <span class="n">kl_array</span><span class="p">,</span> <span class="n">bha_array</span><span class="p">,</span> <span class="n">hel_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findAndNormalizeDistances</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;| Variable             | Kullback | Bhattacharyya | Hellinger |&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">column</span><span class="p">,</span> <span class="n">kl</span><span class="p">,</span> <span class="n">bha</span><span class="p">,</span> <span class="n">hel</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">df1</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;number&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">kl_array</span><span class="p">,</span> <span class="n">bha_array</span><span class="p">,</span> <span class="n">hel_array</span><span class="p">):</span>
      <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;| </span><span class="si">{column:20}</span><span class="s2"> | </span><span class="si">{kl:8.2f}</span><span class="s2"> | </span><span class="si">{bha:13.2f}</span><span class="s2"> | </span><span class="si">{hel:9.2f}</span><span class="s2"> |&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="daco.ks2_test"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.ks2_test">[docs]</a>  <span class="k">def</span> <span class="nf">ks2_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Method using the scipy.stats.ks_2samp for computing the Kolmogorov-</span>
<span class="sd">    Smirnov statistic on two samples. The result is added to a dictionary</span>
<span class="sd">    :class:`ks2_test_val` keeping the results of all calculations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    var1 : str</span>
<span class="sd">      name of variable in the datasets to do the test on.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    statistic : float</span>
<span class="sd">      KS statistic</span>
<span class="sd">    pvalue : float</span>
<span class="sd">      two-tailed p-value</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df1</span>
    <span class="n">df2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df2</span>

    <span class="k">assert</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">df1</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;number&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; is invalid, it must be a continuous variable.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

    <span class="n">data1</span> <span class="o">=</span> <span class="n">df1</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">data2</span> <span class="o">=</span> <span class="n">df2</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="n">statistic</span><span class="p">,</span> <span class="n">pvalue</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">ks_2samp</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">)</span> 

    <span class="bp">self</span><span class="o">.</span><span class="n">ks2_test_val</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;statistic&#39;</span><span class="p">:</span> <span class="n">statistic</span><span class="p">,</span> <span class="s1">&#39;pvalue&#39;</span><span class="p">:</span> <span class="n">pvalue</span> <span class="p">}</span>

    <span class="k">return</span> <span class="n">statistic</span><span class="p">,</span> <span class="n">pvalue</span></div>

<div class="viewcode-block" id="daco.logisticRegressionBenchmark"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.logisticRegressionBenchmark">[docs]</a>  <span class="k">def</span> <span class="nf">logisticRegressionBenchmark</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">eval_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Method for training a logistic regression-model on the datasets</span>
<span class="sd">    and investigate the differences in the model and predictions. The</span>
<span class="sd">    results and models are saved as class variables.</span>

<span class="sd">    Main features:</span>

<span class="sd">    - Training LR-models on synth. and real data (and save them in this class)</span>
<span class="sd">    - Predicting *N* samples</span>
<span class="sd">    - Comparing the accuracy of the two models (several measures possible)</span>
<span class="sd">    - Confusion matrix + classification_report from sklearn</span>
<span class="sd">    - Feature importance</span>

<span class="sd">    :param target: target values</span>
<span class="sd">    :type target: list</span>
<span class="sd">    :param features: features to use in training/predictions</span>
<span class="sd">    :type features: list</span>
<span class="sd">    :param test_size: size of test set</span>
<span class="sd">    :type test_size: float</span>
<span class="sd">    :param eval_size: size of evaluation set</span>
<span class="sd">    :type eval_size: float</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="k">import</span> <span class="n">LogisticRegression</span>
    <span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">confusion_matrix</span><span class="p">,</span> <span class="n">classification_report</span>

    <span class="n">name1</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name1</span>
    <span class="n">name2</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name2</span>
    <span class="n">file_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_dir</span>

    <span class="n">X_train1</span><span class="p">,</span> <span class="n">X_val1</span><span class="p">,</span> <span class="n">y_train1</span><span class="p">,</span> <span class="n">y_val1</span><span class="p">,</span> <span class="n">X_test1</span><span class="p">,</span> <span class="n">y_test1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPrep</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span> <span class="n">eval_size</span><span class="p">,</span> <span class="n">name1</span><span class="p">)</span>
    <span class="n">X_train2</span><span class="p">,</span> <span class="n">X_val2</span><span class="p">,</span> <span class="n">y_train2</span><span class="p">,</span> <span class="n">y_val2</span><span class="p">,</span> <span class="n">X_test2</span><span class="p">,</span> <span class="n">y_test2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPrep</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span> <span class="n">eval_size</span><span class="p">,</span> <span class="n">name2</span><span class="p">)</span>

    <span class="c1"># Training models and calculating their accuracies</span>
    <span class="n">clf1</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train1</span><span class="p">,</span> <span class="n">y_train1</span><span class="p">)</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">clf1</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test1</span><span class="p">,</span> <span class="n">y_test1</span><span class="p">)</span>

    <span class="n">clf2</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train2</span><span class="p">,</span> <span class="n">y_train2</span><span class="p">)</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">clf2</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test2</span><span class="p">,</span> <span class="n">y_test2</span><span class="p">)</span>

    <span class="c1"># saving models in class</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">LR_model1</span>  <span class="o">=</span> <span class="n">clf1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">LR_model2</span>  <span class="o">=</span> <span class="n">clf2</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">score_clf1</span> <span class="o">=</span> <span class="n">s1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">score_clf2</span> <span class="o">=</span> <span class="n">s2</span>

    <span class="c1"># Evaulating and finding confusion matrices</span>
    <span class="n">predictions1</span>  <span class="o">=</span> <span class="n">clf1</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_val1</span><span class="p">)</span>
    <span class="n">predictions2</span>  <span class="o">=</span> <span class="n">clf2</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_val2</span><span class="p">)</span>
    <span class="n">conf_mat1</span>     <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_true</span><span class="o">=</span><span class="n">y_val1</span><span class="p">,</span> <span class="n">y_pred</span><span class="o">=</span><span class="n">predictions1</span><span class="p">)</span>
    <span class="n">conf_mat2</span>     <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_true</span><span class="o">=</span><span class="n">y_val2</span><span class="p">,</span> <span class="n">y_pred</span><span class="o">=</span><span class="n">predictions2</span><span class="p">)</span>
    <span class="n">conf_mat_diff</span> <span class="o">=</span> <span class="n">conf_mat1</span> <span class="o">-</span> <span class="n">conf_mat2</span>

    <span class="c1"># Plotting confusion matrices</span>
    <span class="n">gs</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">gridspec</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">ax2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">ax3</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_plotConfusionMatrixFromLogisticRegression</span><span class="p">(</span><span class="n">conf_mat1</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_plotConfusionMatrixFromLogisticRegression</span><span class="p">(</span><span class="n">conf_mat2</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_plotConfusionMatrixFromLogisticRegression</span><span class="p">(</span><span class="n">conf_mat_diff</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">name2</span> <span class="o">+</span> <span class="s1">&#39; diff&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax3</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">file_dir</span> <span class="o">+</span> <span class="s1">&#39;confusion_matrix_logistic_regression.png&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="daco.dataPrep"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.dataPrep">[docs]</a>  <span class="k">def</span> <span class="nf">dataPrep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span> <span class="n">eval_size</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Data preparation for the ML-models used in DACO. Takes in the two dataframes</span>
<span class="sd">    applies one hot encoding on categorical variables, and splits them into train,</span>
<span class="sd">    test, and evaluation sets.</span>

<span class="sd">    :param target: target values</span>
<span class="sd">    :type target: list</span>
<span class="sd">    :param features: features to use in training/predictions</span>
<span class="sd">    :type features: list</span>
<span class="sd">    :param test_size: size of test set</span>
<span class="sd">    :type test_size: float</span>
<span class="sd">    :param eval_size: size of evaluation set</span>
<span class="sd">    :type eval_size: float</span>
<span class="sd">    :param name: name of dataset to prepare</span>
<span class="sd">    :type name: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="k">import</span> <span class="n">train_test_split</span>

    <span class="c1"># One hot encoding categorical values</span>
    <span class="c1"># TODO if not all values are present in both df1 and df2 we will get</span>
    <span class="c1"># different columns in each dataframe, must be fixed</span>
    <span class="n">oneHotEncode</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="n">features</span><span class="p">]</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;category&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name1</span><span class="p">:</span>
      <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df1</span>
      <span class="n">df</span> <span class="o">=</span> <span class="n">oneHotEncode</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name2</span><span class="p">:</span>
      <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df2</span>
      <span class="n">df</span> <span class="o">=</span> <span class="n">oneHotEncode</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="c1"># generating new features list with one hot encoded features</span>
    <span class="n">features_new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">df_col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">df_col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">column</span><span class="p">):</span>
          <span class="n">features_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_col</span><span class="p">)</span>

    <span class="n">_X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">_y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">features_new</span><span class="p">]</span>
                                                          <span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
                                                          <span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">)</span>
    <span class="n">X_train</span><span class="p">,</span> <span class="n">X_val</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_val</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">_X_train</span><span class="p">,</span> <span class="n">_y_train</span>
                                                      <span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">eval_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">X_val</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span></div>

<div class="viewcode-block" id="daco._plotConfusionMatrixFromLogisticRegression"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco._plotConfusionMatrixFromLogisticRegression">[docs]</a>  <span class="k">def</span> <span class="nf">_plotConfusionMatrixFromLogisticRegression</span><span class="p">(</span><span class="bp">self</span>
      <span class="p">,</span> <span class="n">conf_mat</span>
      <span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
      <span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Plotting method used in :class:`logisticRegressionBenchmark`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">      conf_mat : array</span>
<span class="sd">        confusion matrix output from ``confusion_matrix`` in ``SciPy``</span>
<span class="sd">      title : str</span>
<span class="sd">        title of subplot</span>
<span class="sd">      ax : object</span>
<span class="sd">        axis object for plotting</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">conf_mat</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;True label&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Predicted label&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">title</span><span class="p">))</span></div>

<div class="viewcode-block" id="daco.rowMatching"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.rowMatching">[docs]</a>  <span class="k">def</span> <span class="nf">rowMatching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atol_</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span> <span class="n">rtol_</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Method which loops over each row in synthetic dataset and finds the row</span>
<span class="sd">    in the original dataset with highest match in percent, and saves this number</span>
<span class="sd">    as an attribute to each row in the synthetic dataset.</span>
<span class="sd">    Using numpy.isclose as a matching measure for numerical values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">      atol : float</span>
<span class="sd">        The relative tolerance parameter, see Numpy docs.</span>
<span class="sd">      rtol : float</span>
<span class="sd">        The absolute tolerance parameter, see Numpy docs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">      match_values : array</span>
<span class="sd">        array with dimensions (len(df2), 3) where each row contains</span>
<span class="sd">        ``[&lt;index in df2&gt;, &lt;index in df1&gt;, match_value]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># fetching only columns with numerical values</span>
    <span class="n">df1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df1</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>
    <span class="n">df2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df2</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>
    
    <span class="c1"># initializing dict that will be filled with entries on</span>
    <span class="c1"># the form [&lt;index in df2&gt;, &lt;index in df1&gt;, match_value]</span>
    <span class="n">match_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">df2</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
    
    <span class="n">len_row</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df1</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">row2</span> <span class="ow">in</span> <span class="n">df2</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
      <span class="n">row_match</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">row1</span> <span class="ow">in</span> <span class="n">df1</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
        <span class="c1"># applying np.isclose and counting number of elements inside our tolerances</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">row1</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">row2</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol_</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol_</span><span class="p">)</span>
        <span class="n">match_rel</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">len_row</span>
        <span class="k">if</span> <span class="n">match_rel</span> <span class="o">&gt;=</span> <span class="n">row_match</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
          <span class="n">row_match</span> <span class="o">=</span> <span class="p">[</span><span class="n">row1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">match_rel</span><span class="p">]</span>
      <span class="n">match_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">row2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row_match</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row_match</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">match_values</span> <span class="o">=</span> <span class="n">match_values</span>

    <span class="k">return</span> <span class="n">match_values</span></div>

<div class="viewcode-block" id="daco.hellingerRowForRow"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.hellingerRowForRow">[docs]</a>  <span class="k">def</span> <span class="nf">hellingerRowForRow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Method for comparing finding the pair of rows in the datasets that have</span>
<span class="sd">    the best match.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Very slow implementation!</span>

<span class="sd">    .. todo::</span>
<span class="sd">        Parallellize?</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># fetching only columns with numerical values</span>
    <span class="n">df1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df1</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>
    <span class="n">df2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df2</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>

    <span class="c1"># initializing dict that will be filled with entries on</span>
    <span class="c1"># the form [&lt;index in df2&gt;, &lt;index in df1&gt;, match_value]</span>
    <span class="n">match_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">df2</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
    
    <span class="n">len_row</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df1</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">row2</span> <span class="ow">in</span> <span class="n">df2</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
      <span class="n">row_match</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">row1</span> <span class="ow">in</span> <span class="n">df1</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
        <span class="c1"># applying np.isclose and counting number of elements inside our tolerances</span>
        <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hellingerDivergence</span><span class="p">(</span><span class="n">row1</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">row2</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">match_rel</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">len_row</span>
        <span class="k">if</span> <span class="n">match_rel</span> <span class="o">&gt;=</span> <span class="n">row_match</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
          <span class="n">row_match</span> <span class="o">=</span> <span class="p">[</span><span class="n">row1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">match_rel</span><span class="p">]</span>
      <span class="n">match_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">row2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row_match</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row_match</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">hellinger_row</span> <span class="o">=</span> <span class="n">match_values</span>
    <span class="k">return</span> <span class="n">match_values</span></div>

<div class="viewcode-block" id="daco.syntheticRankingAgreement"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.syntheticRankingAgreement">[docs]</a>  <span class="k">def</span> <span class="nf">syntheticRankingAgreement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_scores</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Method for checking whether the synthetic dataset is useful in machine learning</span>
<span class="sd">    contexts. We use the &quot;Synthetic Ranking Agreement&quot;-method, SRA for short,</span>
<span class="sd">    see `https://arxiv.org/pdf/1806.11345v1.pdf &lt;https://arxiv.org/pdf/1806.11345v1.pdf&gt;`_</span>
<span class="sd">    It is defined as </span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">      \text{SRA} = \frac{1}{k(k-1)} \sum^{k}_{i=1}\sum_{j\neq i} \mathbb{I}\left( (R_i - R_j) \times (S_i - S_j) \right)</span>

<span class="sd">    where :math:`R_k` and :math:`S_k` represents the performance score of algorithm :math:`k` on</span>
<span class="sd">    the real dataset :math:`R` and the synthetic dataset :math:`S` respectively. The SRA can be</span>
<span class="sd">    thought of as the (emprical) probability of a comparison on the synthetic data beain &quot;correct&quot;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">      model_scores : dict</span>
<span class="sd">        dict with scores for the different algorithms on the real and synthetic dataset.</span>
<span class="sd">      target : list</span>
<span class="sd">        list of training targets (if not ``model_scores`` is given)</span>
<span class="sd">      features : list</span>
<span class="sd">        list of training features (if not ``model_scores`` is given)</span>
<span class="sd">      </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">      sra : float</span>
<span class="sd">        a single value which is the result of the formula given above.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name1</span>
    <span class="n">name2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name2</span>
    
    <span class="k">if</span> <span class="n">model_scores</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">_</span><span class="p">,</span> <span class="n">model_scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trainAndTestModels</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">features</span><span class="p">)</span>
      <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_scores</span><span class="p">[</span><span class="n">name1</span><span class="p">])</span> <span class="c1"># number of models/algorithms</span>
      <span class="n">S</span> <span class="o">=</span> <span class="n">model_scores</span><span class="p">[</span><span class="n">name1</span><span class="p">]</span> <span class="c1"># synthetic model scores</span>
      <span class="n">R</span> <span class="o">=</span> <span class="n">model_scores</span><span class="p">[</span><span class="n">name2</span><span class="p">]</span> <span class="c1"># real model scores</span>
    <span class="k">elif</span> <span class="n">model_scores</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_scores</span><span class="p">[</span><span class="n">name1</span><span class="p">])</span>
      <span class="n">S</span> <span class="o">=</span> <span class="n">model_scores</span><span class="p">[</span><span class="n">name1</span><span class="p">]</span>
      <span class="n">R</span> <span class="o">=</span> <span class="n">model_scores</span><span class="p">[</span><span class="n">name2</span><span class="p">]</span>

    <span class="n">sra</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">K</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">K</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
          <span class="n">sra</span> <span class="o">+=</span> <span class="p">((</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">sra</span> <span class="o">*=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">K</span><span class="o">*</span><span class="p">(</span><span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">sra</span></div>

<div class="viewcode-block" id="daco.trainAndTestModels"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.trainAndTestModels">[docs]</a>  <span class="k">def</span> <span class="nf">trainAndTestModels</span><span class="p">(</span><span class="bp">self</span>
                        <span class="p">,</span> <span class="n">target</span>
                        <span class="p">,</span> <span class="n">features</span>
                        <span class="p">,</span> <span class="n">models</span><span class="o">=</span><span class="kc">None</span>
                        <span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span>
                        <span class="p">,</span> <span class="n">eval_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Method for training several ML-models on the two datasets given to this</span>
<span class="sd">    class and do testing as specified by the user. The models and their test</span>
<span class="sd">    scores are saved in dictionaries.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">      target : list</span>
<span class="sd">        target values</span>
<span class="sd">      features: list</span>
<span class="sd">        features to use in training/predictions</span>
<span class="sd">      models : list</span>
<span class="sd">        list of tuples with models and a dict with parameters</span>
<span class="sd">      test_size : float</span>
<span class="sd">        size of test set</span>
<span class="sd">      eval_size : float</span>
<span class="sd">        size of evaluation set</span>
<span class="sd">      </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">      model_dict : dict</span>
<span class="sd">        dictionary with the models trained</span>
<span class="sd">      model_scores : dict</span>
<span class="sd">        dictionary with test scores for the models trained</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name1</span>
    <span class="n">name2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name2</span>
    
    <span class="n">model_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">model_scores</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="p">):</span>
      <span class="n">X_train</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPrep</span><span class="p">(</span><span class="n">target</span>
                                                            <span class="p">,</span> <span class="n">features</span>
                                                            <span class="p">,</span> <span class="n">test_size</span>
                                                            <span class="p">,</span> <span class="n">eval_size</span>
                                                            <span class="p">,</span> <span class="n">name</span><span class="p">)</span>

      <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
      <span class="n">model_dict_</span><span class="p">,</span> <span class="n">model_scores_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trainSeveralModels</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">models</span><span class="p">)</span>

      <span class="n">model_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">model_dict_</span><span class="p">)</span>
      <span class="n">model_scores</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">model_scores_</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">model_dict</span> <span class="o">=</span> <span class="n">model_dict</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">model_scores</span> <span class="o">=</span> <span class="n">model_scores</span>

    <span class="k">return</span> <span class="n">model_dict</span><span class="p">,</span> <span class="n">model_scores</span></div>

<div class="viewcode-block" id="daco._trainSeveralModels"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco._trainSeveralModels">[docs]</a>  <span class="k">def</span> <span class="nf">_trainSeveralModels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">models</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Private method for :class:`trainSynthTestReal` and :class:`syntheticRankingAgreement`.</span>
<span class="sd">    Models and their scores are saved in dictionaries.</span>
<span class="sd">    </span>
<span class="sd">    .. note::</span>
<span class="sd">      This method is constrained to only use</span>
<span class="sd">      models with a ``.fit()``-method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">      name : str</span>
<span class="sd">        name of the entry in the :class:`model_dict` and :class:`model_score`</span>
<span class="sd">      data : tuple</span>
<span class="sd">        tuple with training and test data in the order (X_train, y_train, X_test, y_test)</span>
<span class="sd">      models : list</span>
<span class="sd">        list of tuples with models and a dict with parameters</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">      model_dict : dict</span>
<span class="sd">        dictionary containing all models trained</span>
<span class="sd">      model_scores : dict</span>
<span class="sd">        dictionary containing lists with scores for each model trained</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="k">import</span> <span class="n">RandomForestClassifier</span>
    <span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="k">import</span> <span class="n">GradientBoostingClassifier</span>
    <span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">KNeighborsClassifier</span>
    <span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="k">import</span> <span class="n">LogisticRegression</span>

    <span class="k">if</span> <span class="n">models</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="c1"># choosing default set of models and parameters</span>
      <span class="n">models</span> <span class="o">=</span> <span class="p">[(</span><span class="n">RandomForestClassifier</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">})</span>
                <span class="p">,</span> <span class="p">(</span><span class="n">GradientBoostingClassifier</span><span class="p">,</span> <span class="p">{})</span>
                <span class="p">,</span> <span class="p">(</span><span class="n">KNeighborsClassifier</span><span class="p">,</span> <span class="p">{})</span>
                <span class="p">,</span> <span class="p">(</span><span class="n">LogisticRegression</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;solver&#39;</span> <span class="p">:</span><span class="s1">&#39;liblinear&#39;</span><span class="p">})]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># checking that the input is correct</span>
      <span class="k">for</span> <span class="n">mod</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mod</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;You must provide the model&#39;s parameters in a dictionary.&quot;</span>
    
    <span class="n">model_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">model_scores</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="p">[]}</span>
    
    <span class="k">for</span> <span class="n">mod</span><span class="p">,</span> <span class="n">params</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
      <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Training model </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
      
      <span class="n">clf</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trainSingleModel</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>

      <span class="n">model_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">mod</span><span class="o">.</span><span class="vm">__name__</span> <span class="p">:</span> <span class="n">clf</span><span class="p">}</span>
      <span class="n">model_scores</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">model_dict</span><span class="p">,</span> <span class="n">model_scores</span></div>

<div class="viewcode-block" id="daco._trainSingleModel"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco._trainSingleModel">[docs]</a>  <span class="k">def</span> <span class="nf">_trainSingleModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Private method for training a single model and returning</span>
<span class="sd">    the model and its score</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">      model : object</span>
<span class="sd">        ML-model-object with the methods ``.fit()`` and ``.predict()``</span>
<span class="sd">      params : dict</span>
<span class="sd">        dictionary with hyperparameter to the model</span>
<span class="sd">      X_train : array</span>
<span class="sd">        numpy-array with training data</span>
<span class="sd">      y_train : array</span>
<span class="sd">        numpy-array with training targets</span>
<span class="sd">      X_test : array</span>
<span class="sd">        numpy-array with test data</span>
<span class="sd">      y_test : array</span>
<span class="sd">        numpy-array with test targets</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">      model_trained : object</span>
<span class="sd">        trained model</span>
<span class="sd">      scores : float</span>
<span class="sd">        test score for the model</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">accuracy_score</span>
    
    <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;fit&#39;</span><span class="p">),</span> <span class="s2">&quot;The model </span><span class="si">{}</span><span class="s2"> doesn&#39;t have a .fit()-method.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    
    <span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="n">clf</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">y_train</span><span class="p">))</span> <span class="c1"># Using ravel() since sklearn doesn&#39;t like arrays of shape (m, 1)</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
    <span class="n">score</span> <span class="o">=</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">y_test</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">model</span><span class="p">,</span> <span class="n">score</span></div>

<div class="viewcode-block" id="daco.trainSynthTestReal"><a class="viewcode-back" href="../daco_full_doc.html#daco.daco.trainSynthTestReal">[docs]</a>  <span class="k">def</span> <span class="nf">trainSynthTestReal</span><span class="p">(</span><span class="bp">self</span>
                        <span class="p">,</span> <span class="n">scores</span><span class="o">=</span><span class="kc">None</span>
                        <span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span>
                        <span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="kc">None</span>
                        <span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span>
                        <span class="p">,</span> <span class="n">eval_size</span><span class="o">=</span><span class="mf">0.2</span>
                        <span class="p">,</span> <span class="n">tstr_name</span><span class="o">=</span><span class="s1">&#39;tstr&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Method for training model(s) on synthetic data and test on real data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">      scores : array</span>
<span class="sd">        numpy-array with scores from TSTR</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name1</span>
    <span class="n">name2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name2</span>

    <span class="k">if</span> <span class="n">scores</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="c1"># Loading synthetic training data</span>
      <span class="n">X_train</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPrep</span><span class="p">(</span><span class="n">target</span>
                                                    <span class="p">,</span> <span class="n">features</span>
                                                    <span class="p">,</span> <span class="n">test_size</span>
                                                    <span class="p">,</span> <span class="n">eval_size</span>
                                                    <span class="p">,</span> <span class="n">name1</span><span class="p">)</span>
      <span class="c1"># Loading real test data</span>
      <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPrep</span><span class="p">(</span><span class="n">target</span>
                                                    <span class="p">,</span> <span class="n">features</span>
                                                    <span class="p">,</span> <span class="n">test_size</span>
                                                    <span class="p">,</span> <span class="n">eval_size</span>
                                                    <span class="p">,</span> <span class="n">name2</span><span class="p">)</span>

      <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>

      <span class="n">_</span><span class="p">,</span> <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trainSeveralModels</span><span class="p">(</span><span class="n">tstr_name</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">tstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">[</span><span class="n">tstr_name</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">tstr</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Jon Vegard Sparre, Robindra Prabhu

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>